


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > BaseCachedExternalResourceFetcher</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.cbioportal.genome_nexus.service.cached</a>
</div>

<h1>Coverage Summary for Class: BaseCachedExternalResourceFetcher (org.cbioportal.genome_nexus.service.cached)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BaseCachedExternalResourceFetcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81,2%
  </span>
  <span class="absValue">
    (13/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76,5%
  </span>
  <span class="absValue">
    (75/98)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.cbioportal.genome_nexus.service.cached;
&nbsp;
&nbsp;import com.mongodb.DBObject;
&nbsp;import org.apache.commons.logging.Log;
&nbsp;import org.apache.commons.logging.LogFactory;
&nbsp;import org.cbioportal.genome_nexus.persistence.GenericMongoRepository;
&nbsp;import org.cbioportal.genome_nexus.service.CachedExternalResourceFetcher;
&nbsp;import org.cbioportal.genome_nexus.service.ExternalResourceFetcher;
&nbsp;import org.cbioportal.genome_nexus.service.ResourceTransformer;
&nbsp;import org.cbioportal.genome_nexus.service.exception.ResourceMappingException;
&nbsp;import org.cbioportal.genome_nexus.util.NaturalOrderComparator;
&nbsp;import org.springframework.dao.DataAccessResourceFailureException;
&nbsp;import org.springframework.dao.DataIntegrityViolationException;
&nbsp;import org.springframework.data.mongodb.repository.MongoRepository;
&nbsp;import org.springframework.web.client.HttpClientErrorException;
&nbsp;import org.springframework.web.client.HttpServerErrorException;
&nbsp;import org.springframework.web.client.RestClientException;
&nbsp;
&nbsp;import java.util.*;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;public abstract class BaseCachedExternalResourceFetcher&lt;T, R extends MongoRepository&lt;T, String&gt; &amp; GenericMongoRepository&gt;
&nbsp;    implements CachedExternalResourceFetcher&lt;T&gt;
&nbsp;{
<b class="fc">&nbsp;    private static final Log LOG = LogFactory.getLog(BaseCachedExternalResourceFetcher.class);</b>
&nbsp;
&nbsp;    protected String collection;
&nbsp;    protected R repository;
&nbsp;    protected Class&lt;T&gt; type;
&nbsp;    protected ExternalResourceFetcher&lt;T&gt; fetcher;
&nbsp;    protected ResourceTransformer&lt;T&gt; transformer;
&nbsp;    protected Integer maxPageSize;
&nbsp;
&nbsp;    public BaseCachedExternalResourceFetcher(String collection,
&nbsp;                                             R repository,
&nbsp;                                             Class&lt;T&gt; type,
&nbsp;                                             ExternalResourceFetcher&lt;T&gt; fetcher,
&nbsp;                                             ResourceTransformer&lt;T&gt; transformer)
&nbsp;    {
<b class="fc">&nbsp;        this(collection, repository, type, fetcher, transformer, Integer.MAX_VALUE);</b>
&nbsp;    }
&nbsp;
&nbsp;    public BaseCachedExternalResourceFetcher(String collection,
&nbsp;                                             R repository,
&nbsp;                                             Class&lt;T&gt; type,
&nbsp;                                             ExternalResourceFetcher&lt;T&gt; fetcher,
&nbsp;                                             ResourceTransformer&lt;T&gt; transformer,
&nbsp;                                             Integer maxPageSize)
<b class="fc">&nbsp;    {</b>
<b class="fc">&nbsp;        this.collection = collection;</b>
<b class="fc">&nbsp;        this.repository = repository;</b>
<b class="fc">&nbsp;        this.type = type;</b>
<b class="fc">&nbsp;        this.fetcher = fetcher;</b>
<b class="fc">&nbsp;        this.transformer = transformer;</b>
<b class="fc">&nbsp;        this.maxPageSize = maxPageSize;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Boolean hasValidURI() {
<b class="fc">&nbsp;        return this.fetcher.hasValidURI();</b>
&nbsp;    }
&nbsp;
&nbsp;    // Needs to be overridden to support checking for valid ids
&nbsp;    protected Boolean isValidId(String id)
&nbsp;    {
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    public T fetchAndCache(String id) throws ResourceMappingException
&nbsp;    {
<b class="fc">&nbsp;        boolean saveRawValue = true;</b>
<b class="fc">&nbsp;        Optional&lt;T&gt; instance = null;</b>
&nbsp;
<b class="fc">&nbsp;        if (!isValidId(id)) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            instance = this.repository.findById(id);</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (DataAccessResourceFailureException e) {</b>
<b class="nc">&nbsp;            LOG.warn(&quot;Failed to read from Mongo database - falling back on the external web service. &quot; +</b>
&nbsp;                &quot;Will not attempt to store variant in Mongo database.&quot;);
<b class="nc">&nbsp;            saveRawValue = false;</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        if (!instance.isPresent())</b>
&nbsp;        {
&nbsp;            // get the annotation from the web service and save it to the DB
&nbsp;            try {
&nbsp;                // get the raw annotation string from the web service
<b class="fc">&nbsp;                DBObject rawValue = this.fetcher.fetchRawValue(id);</b>
&nbsp;                // construct an instance to return:
&nbsp;                // this does not contain all the information obtained from the web service
&nbsp;                // only the fields mapped to the VariantAnnotation model will be returned
<b class="fc">&nbsp;                rawValue = this.normalizeResponse(rawValue);</b>
<b class="fc">&nbsp;                List&lt;T&gt; list = this.transformer.transform(rawValue, this.type);</b>
&nbsp;
<b class="fc">&nbsp;                if (list.size() &gt; 0) {</b>
<b class="fc">&nbsp;                    instance = Optional.ofNullable(list.get(0));</b>
&nbsp;                }
&nbsp;
&nbsp;                // save everything to the cache as a properly parsed JSON
<b class="fc">&nbsp;                if (saveRawValue) {</b>
<b class="fc">&nbsp;                    this.repository.saveDBObject(this.collection, id, rawValue);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            catch (DataIntegrityViolationException e) {</b>
&nbsp;                // in case of data integrity violation exception, do not bloat the logs
&nbsp;                // this is thrown when the annotationJSON can&#39;t be stored by mongo
&nbsp;                // due to the variant annotation key being too large to index
<b class="nc">&nbsp;                LOG.info(e.getLocalizedMessage());</b>
<b class="nc">&nbsp;            } catch (HttpServerErrorException e) {</b>
&nbsp;                // failure fetching external resource
<b class="nc">&nbsp;                LOG.error(&quot;Failure fetching external resource: &quot; + e.getLocalizedMessage());</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            return instance.get();</b>
<b class="nc">&nbsp;        } catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public Map&lt;String, T&gt; constructFetchedMap(List&lt;String&gt; ids) throws ResourceMappingException
&nbsp;    {
<b class="fc">&nbsp;        boolean saveValues = true;</b>
<b class="fc">&nbsp;        Set&lt;String&gt; uniqueIds = new LinkedHashSet&lt;&gt;(ids);</b>
<b class="fc">&nbsp;        Map&lt;String, T&gt; idToInstance = initIdToInstanceMap(uniqueIds);</b>
<b class="fc">&nbsp;        Set&lt;String&gt; alreadyCached = new LinkedHashSet&lt;&gt;();</b>
&nbsp;
&nbsp;        try {
&nbsp;            // add everything already cached into the map
<b class="fc">&nbsp;            for (T instance: this.repository.findAllById(uniqueIds))</b>
&nbsp;            {
<b class="nc">&nbsp;                String id = this.extractId(instance);</b>
<b class="nc">&nbsp;                idToInstance.put(id, instance);</b>
<b class="nc">&nbsp;                alreadyCached.add(id);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (DataAccessResourceFailureException e) {</b>
<b class="nc">&nbsp;            LOG.warn(&quot;Failed to read from Mongo database - falling back on the external web service. &quot; +</b>
&nbsp;                &quot;Will not attempt to store variant in Mongo database.&quot;);
<b class="nc">&nbsp;            saveValues = false;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        Set&lt;String&gt; needToFetch = new LinkedHashSet&lt;&gt;(uniqueIds);</b>
&nbsp;
&nbsp;        // remove already cached ids from the set, so that we don&#39;t query again
<b class="fc">&nbsp;        needToFetch.removeAll(alreadyCached);</b>
&nbsp;
&nbsp;        // also remove invalid ids
<b class="fc">&nbsp;        needToFetch = needToFetch.stream().filter(this::isValidId).collect(Collectors.toSet());</b>
&nbsp;        // fetch missing instances
<b class="fc">&nbsp;        if (needToFetch.size() &gt; 0) {</b>
&nbsp;            // get the annotation from the web service and save it to the DB
<b class="fc">&nbsp;            this.fetchAndCache(needToFetch, idToInstance, saveValues);</b>
&nbsp;        }
<b class="fc">&nbsp;        return idToInstance;</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;T&gt; fetchAndCache(List&lt;String&gt; ids) throws ResourceMappingException
&nbsp;    {
<b class="fc">&nbsp;        Map&lt;String, T&gt; idToInstance = constructFetchedMap(ids);</b>
<b class="fc">&nbsp;        Collection&lt;T&gt; values = idToInstance.values();</b>
<b class="fc">&nbsp;        values.removeIf(Objects::isNull);</b>
&nbsp;
<b class="fc">&nbsp;        return new ArrayList&lt;&gt;(values);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void fetchAndCache(Set&lt;String&gt; needToFetch,
&nbsp;                                 Map&lt;String, T&gt; idToInstance,
&nbsp;                                 boolean saveValues) throws ResourceMappingException, HttpClientErrorException
&nbsp;    {
&nbsp;        // send up to maxPageSize entities per request
<b class="fc">&nbsp;        for (Set&lt;String&gt; subSet: this.generateChunks(needToFetch))</b>
&nbsp;        {
<b class="fc">&nbsp;            DBObject rawValue = null;</b>
&nbsp;
&nbsp;            try {
&nbsp;                // get the raw annotation string from the web service
<b class="fc">&nbsp;                rawValue = this.fetcher.fetchRawValue(this.buildRequestBody(subSet));</b>
<b class="fc">&nbsp;            } catch (HttpClientErrorException e) {</b>
<b class="fc">&nbsp;                LOG.error(&quot;HTTP ERROR &quot; + e.getStatusCode() + &quot; for &quot; + subSet.toString() + &quot;: &quot; + e.getResponseBodyAsString(), e);</b>
<b class="nc">&nbsp;            } catch (RestClientException e) {</b>
<b class="nc">&nbsp;                LOG.error(&quot;REST ERROR [&quot; +  e.getLocalizedMessage() + &quot;] for &quot; + subSet.toString(), e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            if (rawValue != null) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    rawValue = this.normalizeResponse(rawValue);</b>
&nbsp;
&nbsp;                    // fetch instances to return:
&nbsp;                    // this does not contain all the information obtained from the web service
&nbsp;                    // only the fields mapped to the VariantAnnotation model will be returned
<b class="fc">&nbsp;                    List&lt;T&gt; fetched = this.transformer.transform(rawValue, this.type);</b>
<b class="fc">&nbsp;                    fetched.forEach(t -&gt; idToInstance.put(this.extractId(t), t));</b>
&nbsp;
&nbsp;                    // save everything to the cache as a properly parsed JSON
<b class="fc">&nbsp;                    if (saveValues) {</b>
<b class="fc">&nbsp;                        this.saveToDb(rawValue);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (DataIntegrityViolationException e) {</b>
&nbsp;                    // in case of data integrity violation exception, do not bloat the logs
&nbsp;                    // this is thrown when the annotationJSON can&#39;t be stored by mongo
&nbsp;                    // due to the variant annotation key being too large to index
<b class="nc">&nbsp;                    LOG.info(e.getLocalizedMessage());</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    protected List&lt;LinkedHashSet&lt;String&gt;&gt; generateChunks(Set&lt;String&gt; needToFetch)
&nbsp;    {
<b class="fc">&nbsp;        List&lt;LinkedHashSet&lt;String&gt;&gt; chunks = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        List&lt;String&gt; sortedUncachedRegions = new ArrayList&lt;&gt;(needToFetch);</b>
<b class="fc">&nbsp;        Collections.sort(sortedUncachedRegions, new NaturalOrderComparator());</b>
&nbsp;
&nbsp;        // chunk size should be at most maxPageSize
<b class="fc">&nbsp;        for (int i = 0; i &lt; sortedUncachedRegions.size(); i += this.maxPageSize) {</b>
<b class="fc">&nbsp;            chunks.add(new LinkedHashSet&lt;&gt;(sortedUncachedRegions.subList(i, Math.min(sortedUncachedRegions.size(), i + this.maxPageSize))));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return chunks;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void saveToDb(DBObject rawValue)
&nbsp;    {
<b class="fc">&nbsp;        List&lt;DBObject&gt; dbObjects = this.transformer.transform(rawValue);</b>
&nbsp;
<b class="fc">&nbsp;        for (DBObject dbObject: dbObjects) {</b>
<b class="fc">&nbsp;            dbObject.put(&quot;_id&quot;, this.extractId(dbObject));</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // filter out objects with invalid ids, do not save them to DB!
<b class="fc">&nbsp;        dbObjects = dbObjects.stream()</b>
<b class="fc">&nbsp;            .filter(o -&gt; o.get(&quot;_id&quot;) != null)</b>
<b class="fc">&nbsp;            .collect(Collectors.toList());</b>
&nbsp;
<b class="fc">&nbsp;        this.repository.saveDBObjects(this.collection, dbObjects);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, T&gt; initIdToInstanceMap(Set&lt;String&gt; ids)
&nbsp;    {
<b class="fc">&nbsp;        Map&lt;String, T&gt; map = new LinkedHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        // this will ensure the final map has the same order of the input ids
<b class="fc">&nbsp;        ids.forEach(id -&gt; map.put(id, null));</b>
&nbsp;
<b class="fc">&nbsp;        return map;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Needs to be overridden by child classes to support multi fetch and cache!
&nbsp;    protected String extractId(T instance)
&nbsp;    {
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Needs to be overridden by child classes to support multi fetch and cache!
&nbsp;    protected String extractId(DBObject dbObject)
&nbsp;    {
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    // No sanitization by default, just assume that response is consistent
&nbsp;    protected DBObject normalizeResponse(DBObject rawValue) {
<b class="fc">&nbsp;        return rawValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected Object buildRequestBody(Set&lt;String&gt; ids)
&nbsp;    {
<b class="nc">&nbsp;        return ids;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-18 22:00</div>
</div>
</body>
</html>
